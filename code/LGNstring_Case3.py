"""
31st August: Upon discussion with Riccardo - we identified 4 cases under which we would like
to collect data. This is an instance of Case III where we have inter-node connections between
TCR and TRN as well as TRN and TRN for all neighbouring nodes. Thus, each node receives input
(gives output) from (to) exactly 2 neighbouring nodes.

27th August: Extending lateral connections between neighbouring TCR and TRN
which is Case II of III.
Collected data with 300 nodes, when in 2 tcr weight is 8, the tcr has suppressed firing rate as do the trn.
But when the in to tcr weight is reduced to 4, the trn and tcr do show signs of the dc input pulse.
now I am experimenting with scaling up all the weights by 2 within the class definition by defining a local
variable sc. This is a temporary inclusion. Need to formalise if the results make any sense.

25th August: I have today defined the poisson source in the main so that the
same source can provide input to all the instances.
I have reduced the time scale factor in .spynnaker.cfg to 10 so we have much faster simulation now.
It needs to be set back to 300 though when scaling up.
And I am experimenting with different poisson inputs to the different populations

24th August: As discussed with Riccardo on 22nd August, this is Case 1 of 3 implementation.
The number of neurons in a single instance is scaled down to 140.
Noise is provided to all three populations.
Intra-instance connection is between IN-TCR and TCR-TRN.
Inter-instance connection is between TRN-TRN.

20th August: Finally able to get back to work today - had been heavy duty on the home front
during the past month or so -
OK - so today I will be looking into adding noise and generating rasters as generated by
Riccardo on Matlab using a simple neural network.

5th August: In this version 3.0, I am adding noise to see if the stability of the network
is improved.

1st-4th august - Testing for a total duration of 2 seconds - some parameter adjustments
as TRN is on overdrive in the previous settings and when the instance size is scaled
up from 140 to 1400. I have altered the time-constant parameters and reverted to the
original value of 1.7 and 2.5. I also had to reduce the connection weight from tcr
to trn to 0.5. The connection weight of in to tcr is also set to 8 as in the original
parameter set of the LGN instance. These alterations seem to scale down the average
spike count of TRN to the 100-s range rather than the 1000-s range that it was showing
earlier.

27-07-2018: In the 2.0 version,
the DC pulse input will be given only to the three central instances.
So, for a string of 5 instances, this will be provided to the
2nd, 3rd and 4th instances.
Note that to find a good mid-point, we keep the number of instances odd at this point.

I also changed the shape of the pulses thus:
All instances will have a DC current of 4 to start with.
After 1000 msec, the middle instances as mentioned above will be fed by pulses thus:
20 DC for 2000 msec, 60 DC for 4000 msec, 20 DC for 2000 msec, and back to 4 DC
for the remaining 1000 msec of a total duration of 10 seconds.

(1) Tested 5 instances, with pulse input to the middle 3 instances;
(2) and now moving to 105 instances in the string. providing
input to the middle five instances.
(3) Next, to observe the effect of IN, increased the p_in2tcr to 0.3 (was 0.15).
Also, reduced the number of instances in the string to 25, and let the pulse
input nodes remain as the central 5 instances.
Collected the results and will check on matlab now.
(4) Repeat the above simulation i.e. 25 nodes, but in to tcr reverted to original value.
(5) Last for today - just scaled up each instance by 100 instead of 10 so total
number of neurons will be 1400. Will see. This is running on the big machine. CRASHED AGAIN!
Trying now by reducing the number of neurons per core.

26-07-2018: Wrote the code to create a string of LGN instances, where
each node is connected to the two neighbours on either side. TCR and TRN
do not connect within the instance, but only to neighbouring populations.
IN connect only locally i.e. within the instance.
Edge instances are wrapped around.

Simulated with TRN DC input at 0 and 4.
DC pulse input provided to the TCR and TRN input of all instances.
Currently on-time height is 60 DC and off-time (base) height is 20 DC.
The LGN string in both cases has 100 instances.

19-07-2018: Meeting with Riccardo---We need to make a line of LGN instances
and then wrap them around.

"""

# !/usr/bin/python

import numpy as np

import matplotlib.pylab as plt
import pylab
from pylab import *
from pyNN.random import NumpyRNG, RandomDistribution

import spynnaker8 as p
import pyNN.utility.plotting as plot
from pyNN.utility.plotting import Figure, Panel


import time
start_time = time.time()

class lgn_microcol():

    def __init__(self, p, scale_fact, DCbase):
        self.NumCellsTCR = int(8*scale_fact)
        self.NumCellsIN = int(2*scale_fact)
        self.NumCellsTRN = int(4*scale_fact)

        ''' Initialising Model connectivity parameters'''
        self.intra_pop_delay = 1
        self.intra_nucleus_delay = 2
        self.inter_node_delay = 3

        ''' THE STRENGTH OF CONNECTION TO THE
        RELAY CELLS ARE KNOWN TO BE VERY STRONG. HENCE THEY ARE SET TO 5.0. ON THE OTHER
        HAND THE CONNECTION TO INTERNEURONS ARE KNOWN TO BE FAR AWAY FROM THE SOMA. THEREFORE
        THEY ARE SET TO 1.0. THOSE FOR THE TRN ARE SET TO 2.0. THESE ARE OFCOURSE ARBITRARY
        FIGURES.'''
        self.p_in2tcr = 0.15 ##0.3 ## change to test effect of IN
        self.p_in2in = 0.236


        self.w_in2tcr= 2.0 ## 4.0##change to test effect of IN
        self.w_in2in = 2.0

        self.w_tcr2trn_internode = 2.0
        self.p_tcr2trn_internode = 0.35
        self.w_trn2trn_internode = 2.0
        self.p_trn2trn_internode = 0.2
        self.w_trn2tcr_internode = 2.0
        self.p_trn2tcr_internode = 0.15


        ''' Initialising Izhikevich spiking neuron model parameters.
        We have used the current-based model here.'''

        # Tonic mode parameters
        self.tcr_a_tonic = 0.02
        self.tcr_b_tonic = 0.2
        self.tcr_c_tonic = -65.0
        self.tcr_d_tonic = 6.0
        self.tcr_v_init_tonic = -65.0

        self.in_a_tonic = 0.1
        self.in_b_tonic = 0.2
        self.in_c_tonic = -65.0
        self.in_d_tonic = 6.0
        self.in_v_init_tonic = -70.0

        self.trn_a_tonic = 0.02
        self.trn_b_tonic = 0.2
        self.trn_c_tonic = -65.0
        self.trn_d_tonic = 6.0
        self.trn_v_init_tonic = -75.0

        self.tcr_u_init_tonic = self.tcr_b_tonic * self.tcr_v_init_tonic
        self.in_u_init_tonic = self.in_b_tonic * self.in_v_init_tonic
        self.trn_u_init_tonic = self.trn_b_tonic * self.trn_v_init_tonic

        self.current_Pulse = DCbase ##a constant dc bias current;
        self.tau_ex = 1.7 ###6 ##  excitatory input time constant
        self.tau_inh = 2.5 ###4 ## inhibitory input time constant

        '''Defining each cell type as dictionary'''

        # THALAMOCORTICAL RELAY CELLS (TCR)

        self.TCR_cell_params = {'a': self.tcr_a_tonic, 'b': self.tcr_b_tonic, 'c': self.tcr_c_tonic,
                                'd': self.tcr_d_tonic, 'v': self.tcr_v_init_tonic, 'u': self.tcr_u_init_tonic, 								'tau_syn_E': self.tau_ex, 'tau_syn_I': self.tau_inh,
                                'i_offset': self.current_Pulse
                                }

        # THALAMIC INTERNEURONS (IN)

        self.IN_cell_params = {'a': self.in_a_tonic, 'b': self.in_b_tonic, 'c': self.in_c_tonic,
                                'd': self.in_d_tonic, 'v': self.in_v_init_tonic, 'u': self.in_u_init_tonic, 								'tau_syn_E': self.tau_ex, 'tau_syn_I': self.tau_inh,
                                'i_offset': self.current_Pulse
                                }

        # THALAMIC RETICULAR NUCLEUS (TRN)

        self.TRN_cell_params = {'a': self.trn_a_tonic, 'b': self.trn_b_tonic, 'c': self.trn_c_tonic,
                                'd': self.trn_d_tonic, 'v': self.trn_v_init_tonic, 'u': self.trn_u_init_tonic,
                                'tau_syn_E': self.tau_ex, 'tau_syn_I': self.tau_inh,
                                'i_offset': self.current_Pulse
                           }

        '''Creating populations of each cell type'''
        self.TCR_pop = p.Population(self.NumCellsTCR, p.Izhikevich(**self.TCR_cell_params), label='TCR_pop')
        self.IN_pop = p.Population(self.NumCellsIN, p.Izhikevich(**self.IN_cell_params), label='IN_pop')
        self.TRN_pop = p.Population(self.NumCellsTRN, p.Izhikevich(**self.TRN_cell_params), label='TRN_pop')

        '''IN2TCR'''
        self.Proj4 = p.Projection(self.IN_pop, self.TCR_pop,
                                  p.FixedProbabilityConnector(p_connect=self.p_in2tcr),
                                  synapse_type=p.StaticSynapse(weight=self.w_in2tcr, delay=self.intra_nucleus_delay), receptor_type='inhibitory')


        '''IN2IN'''
        self.Proj5  = p.Projection(self.IN_pop, self.IN_pop,
                                   p.FixedProbabilityConnector(p_connect=self.p_in2in),
                                   synapse_type=p.StaticSynapse(weight=self.w_in2in, delay=self.intra_pop_delay), receptor_type='inhibitory')

        '''TCR2TRN'''
        self.Proj6 = p.Projection(self.TCR_pop, self.TRN_pop,
                     p.FixedProbabilityConnector(p_connect=self.p_tcr2trn_internode),
                     p.StaticSynapse(weight=self.w_tcr2trn_internode, delay=self.inter_node_delay),
                     receptor_type='excitatory')

        '''TRN2TCR'''
        self.Proj7 = p.Projection(self.TRN_pop, self.TCR_pop,
                     p.FixedProbabilityConnector(p_connect=self.p_trn2tcr_internode),
                     p.StaticSynapse(weight=self.w_trn2tcr_internode, delay=self.inter_node_delay),
                     receptor_type='inhibitory')

        '''TRN2TRN'''

        self.Proj8 = p.Projection(self.TRN_pop, self.TRN_pop,
                     p.FixedProbabilityConnector(p_connect=self.p_trn2trn_internode),
                     p.StaticSynapse(weight=self.w_trn2trn_internode, delay=self.inter_node_delay),
                     receptor_type='inhibitory')

    def recordSpikes(self):

        self.TCR_pop.record(['spikes'])
        self.IN_pop.record(['spikes'])
        self.TRN_pop.record(['spikes'])

def getDisplaySpikes(lgn_module,v):
    print 'within getdisplay function'

    TCR_spikes = lgn_module.TCR_pop.spinnaker_get_data("spikes")
    IN_spikes = lgn_module.IN_pop.spinnaker_get_data("spikes")
    TRN_spikes = lgn_module.TRN_pop.spinnaker_get_data("spikes")

    plt.figure(1)
    plt.subplot(3,1,1)
    plt.plot(TCR_spikes[:, 1], TCR_spikes[:, 0], '.r')
    plt.subplot(3,1,2)
    plt.plot(IN_spikes[:, 1], IN_spikes[:, 0], '.b')
    
    plt.subplot(3,1,3)
    plt.plot(TRN_spikes[:, 1], TRN_spikes[:, 0], '.g')
    
    plt.show()



##    filenameTCR = './Data_Case3/TCRspikeraster_node%02d.csv' % (v)
##    np.savetxt(filenameTCR, TCR_spikes)
##
##    filenameIN = './Data_Case3/INspikeraster_node%02d.csv' % (v)
##    np.savetxt(filenameIN, IN_spikes)
##
##    filenameTRN = './Data_Case3/TRNspikeraster_node%02d.csv' % (v)
##    np.savetxt(filenameTRN, TRN_spikes)



if __name__ == "__main__":
    totalDuration=10000 ####2000 ##  total duration of simulation
    time_resol = 0.1 ## time-step of model equation solver
    TimeInt = 1/time_resol
    TotalDataPoints = totalDuration * TimeInt ##for a solution time-step of 0.1

    '''Pulse time lengths'''
    duration1 = 1000 ###200##
    duration2 = 2000 ###400###
    duration3 = 3000 ####800###

    '''Define the population scale and the base DC value'''
    scale_fact = 10
    DCbase = 4
    DCpulse1 = 30
    DCpulse2 = 90
    DCpulse3 = 270


    '''DEFINE THE STRING SIZE'''
    stringSize = 1000 ###5#

    '''SET SOME OF THE NOISE PARAMETERS'''
    NumPoissonInputs2TCR = int(8*scale_fact / 2)
    NumPoissonInputs2IN = int(2*scale_fact / 2)
    NumPoissonInputs2TRN = int(4*scale_fact / 2)
    p_noise2tcr = 0.07
    w_noise2tcr = 5.0
    p_noise2in = 0.47
    w_noise2in = 2.0
    

    inter_node_delay=3.0

    ''' SET UP SPINNAKER AND BEGIN SIMULATION'''

    p.setup(timestep=time_resol, min_delay=1, max_delay=14.0)
    #p.set_number_of_neurons_per_core(p.Izhikevich, 25)

    '''DEFINE THE NOISY INPUT COMMON TO ALL NODES'''
    ratePoissonInput_1 = 30
    ratePoissonInput_2 = 30
    ratePoissonInput_3 = 30
    startPoissonInput = p.RandomDistribution("uniform", [10, 50])  ###0[500, 700]
    durationPoissonInput =9950 ##1950  ##  ####TotalDuration

    noiseSource2TCR = p.Population(NumPoissonInputs2TCR, p.SpikeSourcePoisson,
                                        {'rate': ratePoissonInput_2,
                                         'duration': durationPoissonInput,
                                         'start': startPoissonInput},
                                        label='noiseSource2TCR')

    noiseSource2IN = p.Population(NumPoissonInputs2IN, p.SpikeSourcePoisson,
                                       {'rate': ratePoissonInput_1,
                                        'duration': durationPoissonInput,
                                        'start': startPoissonInput},
                                       label='noiseSource2IN')

    noiseSource2TRN = p.Population(NumPoissonInputs2TRN, p.SpikeSourcePoisson,
                                        {'rate': ratePoissonInput_3,
                                         'duration': durationPoissonInput,
                                         'start': startPoissonInput},
                                        label='noiseSource2TRN')

    '''FORM THE LGN string CONSISTING OF XXX NODES, WHERE EACH NODE IS AN LGN INSTANCE.
    EACH NODE RECEIVES PROJECTION FROM THE NOISE SOURCE DEFINED ABOVE, PARAMETERS OF CONNECTION
    ARE ALSO STATED ABOVE.'''
    lgn_string = []
    for i in range(0, stringSize):
        lgn_nodeX = lgn_microcol(p, scale_fact, DCbase)
        '''NOISE2TCR'''

        Proj1 = p.Projection(noiseSource2TCR, lgn_nodeX.TCR_pop,
                                  p.FixedProbabilityConnector(p_connect=p_noise2tcr),
                                  synapse_type=p.StaticSynapse(weight=w_noise2tcr, delay=inter_node_delay),
                                  receptor_type='excitatory')

        '''NOISE2IN'''
        Proj2 = p.Projection(noiseSource2IN, lgn_nodeX.IN_pop,
                                  p.FixedProbabilityConnector(p_connect=p_noise2in),
                                  synapse_type=p.StaticSynapse(weight=w_noise2in, delay=inter_node_delay),
                                  receptor_type='excitatory')
##
##        '''NOISE2TRN'''
##        Proj3 = p.Projection(noiseSource2TRN, lgn_nodeX.TRN_pop,
##                                  p.FixedProbabilityConnector(p_connect=p_noise2trn),
##                                  synapse_type=p.StaticSynapse(weight=w_noise2trn, delay=inter_node_delay),
##                                  receptor_type='excitatory')

        lgn_string.append(lgn_nodeX)
        print ('size of LGN string is %d') % size(lgn_string)
        print ('length of LGN string is %d') % len(lgn_string)


    '''NEXT, WE CREATE THE STRING CONNECTIONS'''
    n1vect = []
    n0vect = []
    for numcon in range(0, stringSize):
        n0 = numcon
        n1 = np.random.uniform(0, stringSize, 1)
        n1 = int(n1)
        if n1 == numcon:
            n1 = numcon+1

        lgn_nodeN = lgn_string[n0]
        lgn_nodeN1 = lgn_string[n1]

        n1vect.append(n1)
        n0vect.append(n0)

        '''TRN TO TRN LATERAL INTER-NODE CONNECTION'''
        p.Projection(lgn_nodeN.TRN_pop, lgn_nodeN1.TRN_pop,
                     p.FixedProbabilityConnector(p_connect=lgn_nodeN.p_trn2trn_internode),
                     p.StaticSynapse(weight=lgn_nodeN.w_trn2trn_internode, delay=lgn_nodeN.inter_node_delay),
                     receptor_type='inhibitory')


        p.Projection(lgn_nodeN1.TRN_pop, lgn_nodeN.TRN_pop,
                     p.FixedProbabilityConnector(p_connect=lgn_nodeN.p_trn2trn_internode),
                     p.StaticSynapse(weight=lgn_nodeN.w_trn2trn_internode, delay=lgn_nodeN.inter_node_delay),
                     receptor_type='inhibitory')

        '''TCR TO TRN LATERAL INTER-NODE CONNECTION'''
        p.Projection(lgn_nodeN.TCR_pop, lgn_nodeN1.TRN_pop,
                    p.FixedProbabilityConnector(p_connect=lgn_nodeN.p_tcr2trn_internode),
                    p.StaticSynapse(weight=lgn_nodeN.w_tcr2trn_internode, delay=lgn_nodeN.inter_node_delay),
                    receptor_type='excitatory')

        p.Projection(lgn_nodeN1.TCR_pop, lgn_nodeN.TRN_pop,
                     p.FixedProbabilityConnector(p_connect=lgn_nodeN.p_tcr2trn_internode),
                     p.StaticSynapse(weight=lgn_nodeN.w_tcr2trn_internode, delay=lgn_nodeN.inter_node_delay),
                     receptor_type='excitatory')

        '''TRN TO TCR LATERAL INTER-NODE CONNECTION'''

        p.Projection(lgn_nodeN.TRN_pop, lgn_nodeN1.TCR_pop,
                     p.FixedProbabilityConnector(p_connect=lgn_nodeN.p_trn2tcr_internode),
                     p.StaticSynapse(weight=lgn_nodeN.w_trn2tcr_internode, delay=lgn_nodeN.inter_node_delay),
                     receptor_type='inhibitory')


        p.Projection(lgn_nodeN1.TRN_pop, lgn_nodeN.TCR_pop,
                     p.FixedProbabilityConnector(p_connect=lgn_nodeN.p_trn2tcr_internode),
                     p.StaticSynapse(weight=lgn_nodeN.w_trn2tcr_internode, delay=lgn_nodeN.inter_node_delay),
                     receptor_type='inhibitory')

    for j in range(len(lgn_string)):
        lgn_nodeY = lgn_string[j]
        lgn_nodeY.recordSpikes()

    noiseSource2TCR.record(['spikes'])
    noiseSource2IN.record(['spikes'])
##    noiseSource2TRN.record(['spikes'])

    # p.run(totalDuration)

    p.run(duration1)

    '''PROVIDING PULSE TO THE MIDDLE 5 INSTANCES (k in range(-2,3))
    OF THE TOTAL OF 105 INSTANCES.
    PREVIOUSLY, TESTED WITH 5 INSTANCES, AND PROVIDED INPUT TO THE
    MIDDLE 3 INSTANCES (k in range(-1,2)).
    29TH AUGUST 2018: SUBSEQUENTLY, WE MOVED TO 1000 INSTANCES, AND WE PROVIDE PULSE INPUT TO THE MIDDLE
    200 INSTANCES'''
    leftspread=-100
    rightspread = 100
    if stringSize >= 5:
        for k in range(leftspread, rightspread):
            centralNode = int(ceil(len(lgn_string)/2))+k
            lgn_nodeZ = lgn_string[centralNode]
            lgn_nodeZ.TCR_pop.set(i_offset=DCpulse1)
            lgn_nodeZ.IN_pop.set(i_offset=DCpulse1)
    else:
        lgn_nodeZ = lgn_string[1]
        lgn_nodeZ.TCR_pop.set(i_offset=DCpulse1)
        lgn_nodeZ.IN_pop.set(i_offset=DCpulse1)

    p.run(duration2)

    if stringSize >= 5:
        for k in range(leftspread, rightspread):
            centralNode = int(ceil(len(lgn_string)/2))+k
            lgn_nodeZ = lgn_string[centralNode]
            lgn_nodeZ.TCR_pop.set(i_offset=DCpulse2)
            lgn_nodeZ.IN_pop.set(i_offset=DCpulse2)
    else:
        lgn_nodeZ = lgn_string[1]
        lgn_nodeZ.TCR_pop.set(i_offset=DCpulse2)
        lgn_nodeZ.IN_pop.set(i_offset=DCpulse2)

    p.run(duration3)

    if stringSize >= 5:
        for k in range(leftspread, rightspread):
            centralNode = int(ceil(len(lgn_string)/2))+k
            lgn_nodeZ = lgn_string[centralNode]
            lgn_nodeZ.TCR_pop.set(i_offset=DCpulse3)
            lgn_nodeZ.IN_pop.set(i_offset=DCpulse3)
    else:
        lgn_nodeZ = lgn_string[1]
        lgn_nodeZ.TCR_pop.set(i_offset=DCpulse3)
        lgn_nodeZ.IN_pop.set(i_offset=DCpulse3)

    p.run(duration3)

    # if stringSize >= 5:
    #     for k in range(leftspread, rightspread):
    #         centralNode = int(ceil(len(lgn_string)/2))+k
    #         lgn_nodeZ = lgn_string[centralNode]
    #         lgn_nodeZ.TCR_pop.set(i_offset=DCpulse1)
    #         lgn_nodeZ.IN_pop.set(i_offset=DCpulse1)
    # else:
    #     lgn_nodeZ = lgn_string[1]
    #     lgn_nodeZ.TCR_pop.set(i_offset=DCpulse1)
    #     lgn_nodeZ.IN_pop.set(i_offset=DCpulse1)
    #
    # p.run(duration2)

    if stringSize >= 5:
        for k in range(leftspread, rightspread):
            centralNode = int(ceil(len(lgn_string)/2))+k
            lgn_nodeZ = lgn_string[centralNode]
            lgn_nodeZ.TCR_pop.set(i_offset=DCbase)
            lgn_nodeZ.IN_pop.set(i_offset=DCbase)
    else:
        lgn_nodeZ = lgn_string[1]
        lgn_nodeZ.TCR_pop.set(i_offset=DCbase)
        lgn_nodeZ.IN_pop.set(i_offset=DCbase)

    p.run(duration1)

    noiseSource2TCR_spikes = noiseSource2TCR.spinnaker_get_data("spikes")
    noiseSource2IN_spikes = noiseSource2IN.spinnaker_get_data("spikes")
    noiseSource2TRN_spikes = noiseSource2TRN.spinnaker_get_data("spikes")
    plt.figure(2)
    plt.subplot(3, 1, 1)
    plt.plot(noiseSource2TCR_spikes[:, 1], noiseSource2TCR_spikes[:, 0], '.r')

    plt.subplot(3, 1, 2)
    plt.plot(noiseSource2IN_spikes[:, 1], noiseSource2IN_spikes[:, 0], '.b')

    plt.subplot(3, 1, 3)
    plt.plot(noiseSource2TRN_spikes[:, 1], noiseSource2TRN_spikes[:, 0], '.g')
    plt.show()

    filenameTCRnoise = './Data_Case3/noiseSource2TCR_spikeraster.csv'
    np.savetxt(filenameTCRnoise, noiseSource2TCR_spikes)

    filenameINnoise = './Data_Case3/noiseSource2IN_spikeraster.csv'
    np.savetxt(filenameINnoise, noiseSource2IN_spikes)

    filenameTRNnoise = './Data_Case3/noiseSource2TRN_spikeraster.csv'
    np.savetxt(filenameTRNnoise, noiseSource2TRN_spikes)

    filename_n1 = './Data_Case3/n1vect.csv'
    np.savetxt(filename_n1, n1vect)

    filename_n0 = './Data_Case3/n0vect.csv'
    np.savetxt(filename_n0, n0vect)

    for w in range(len(lgn_string)):
        lgn_nodeW = lgn_string[w]
        getDisplaySpikes(lgn_nodeW, w)
        print ("getting the %d th spikes") %w

    p.end()
    print("--- %s SECONDS ELAPSED ---\n \n \n" % (time.time() - start_time))
